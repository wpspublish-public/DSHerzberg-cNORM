---
title: "Using cNORM's weighting feature"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### Overview

`cNORM`[^1] includes a function for weighting data from
non-demographically representative normative samples. The weighting
function is designed to correct bias in the raw-to-norm-score
relationships that might be introduced by non-representative data.

[^1]: The core documentation for the use of `cNORM` is provided in
    ***Generating raw-to-norm-score lookup tables with cNORM*****.**

This markdown document expands on a demonstration of the weighting
function prepared by the `cNORM` author group. To run the demonstration,
set up an RStudio project called `cNORM`, with subfolders `CODE`,
`INPUT-FILES` and `OUTPUT-FILES`. Save scripts in `CODE`, and run them
from within the `cNORM` project.

For normative data, the script uses the `ppvt` (Peabody Picture
Vocabulary Test) data set, which is included in the `cNORM` package.
Weighting is applied with respect to two demographic variables, each
with two categories (levels): `sex` (`1` = `male`, `2` = `female`) and
`migration` status (`0` = `no`, `1` = `yes`). `cNORM`'s weighting
function requires target percentages for the demographic categories,
which are usually obtained from US Census data.[^2]

[^2]: Ersatz target percentages are use in the current demonstration.

To understand the procedures described below, it's useful to visualize a
two-by-two contingency table, with rows for the values of `sex` and
columns for the values of `migration`. This table has four joint
cross-classification cells, representing the four possible combinations
of the categories of `sex` and `migration`.

We can represent the target percentages for each demographic variable on
the table margins (that is, on the left and upper edges of the table.)
These *marginal percentages*, of course, sum to 100% for each variable.
The cells contain the *joint classification percentages* (also summing
to 100%), which are obtained by multiplying the marginal percentages for
each cell's row and column.

|                    |   Non-migrant (65.0%)   |       Migrant (35.0%)       |
|-------------------:|:-----------------------:|:---------------------------:|
|   **Male (51.0%)** |  Male, Migrant (33.1%)  |  Male, Non-migrant (17.9%)  |
| **Female (49.0%)** | Female, Migrant (31.8%) | Female, Non-migrant (17.2%) |

*Marginal* and *joint* are often used analogously to modify terms such
as *proportion*, *distribution*, and so on. "Marginal" thus refers to
the categories of a single variable, considered independently from all
others, and "joint" refers to the crossing of categories of two or more
variables.

The target percentages are the standard of demographic
representativeness. To compensate for non-representativeness in the
normative sample, `cNORM`uses the target percentages to calculate
weighting multipliers. These weights are applied at the raw-score level
to adjust the parameters of the raw-score distributions within
demographic categories. The intended effect is for the weighted raw
scores to have the same numerical impact on the norming process as would
unweighted raw scores in a demographically representative normative
sample (i.e., one in which the sample percentages match the target
percentages).

`cNORM` determines the weights by means of an iterative mathematical
process called *raking*. Importantly, raking operates only on the
marginal percentages. The underlying equations do not explicitly
incorporate the joint percentages. So, although target joint percentages
are sometimes available in US Census data, they are never used as inputs
for `cNORM`'s weighting function.

#### Executable Code

```{r cNORM-weighting-demo, eval = FALSE}
suppressMessages(library(cNORM))
suppressMessages(suppressWarnings(library(tidyverse)))

norm_data <- ppvt
View(norm_data)

marginals_ppvt <- data.frame(var = c("sex", "sex", "migration", "migration"),
                             level = c(1,2,0,1),
                             prop = c(0.5100, 0.4900, 0.6500, 0.3500))
View(marginals_ppvt)

prop.table(xtabs(~sex, data = norm_data))
prop.table(xtabs(~migration, data = norm_data))
prop.table(xtabs(~sex + migration, data = norm_data))

norm_data <- norm_data %>% 
  mutate(weights = computeWeights(data = norm_data, population.margins = marginals_ppvt))

norm_data_weights <- norm_data %>%
  group_by(sex, migration) %>%
  summarize(weights = unique(weights))
View(norm_data_weights)

model_weighted <- cnorm(raw = norm_data$raw,
                       group = norm_data$group,
                       weights = norm_data$weights,
                       scale = "IQ")

model_unweighted <- cnorm(raw = norm_data$raw,
                       group = norm_data$group,
                       scale = "IQ")

age_strat <- c(3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 
                 11.5, 12.5, 13.5, 14.5, 15.5, 16.5)

norms_list_weighted <- rawTable(
  age_strat,
  model_weighted,
  step = 1,
  minNorm = 40,
  maxNorm = 130,
  minRaw = 7,
  maxRaw = 221,
  pretty = FALSE
) %>%
  map(~
        select(.x, raw, norm) %>%
        summarize(raw = raw,
                  ss = round(norm, 0)))

table_weighted <- norms_list_weighted %>%
  reduce(left_join,
         by = "raw") %>%
  set_names("raw", age_strat)

norms_list_unweighted <- rawTable(
  age_strat,
  model_unweighted,
  step = 1,
  minNorm = 40,
  maxNorm = 130,
  minRaw = 7,
  maxRaw = 221,
  pretty = FALSE
) %>%
  map(~
        select(.x, raw, norm) %>%
        summarize(raw = raw,
                  ss = round(norm, 0)))

table_unweighted <- norms_list_unweighted %>%
  reduce(left_join,
         by = "raw") %>%
  set_names("raw", age_strat)

comp_w_uw <-full_join(
  table_weighted,
  table_unweighted,
  by = "raw"
) %>% 
  select(-raw)

chi <- sapply(seq_len(nrow(comp_w_uw)), function(x) {
  chisq.test(matrix(as.numeric(comp_w_uw[x, 1:28]), nrow = 2, 14, 2))$statistic
})
comp_w_uw$chi_square <- chi

chi_sq_max <- max(comp_w_uw$chi_square)
df <- length(age_strat) - 1
```

#### Commented Snippets

Load packages for norming (`cNORM`) and data wrangling (`tidyverse`).
Assign the `ppvt` data set to the `norm_data` object. `View()` the data
set to inspect the following columns:

-   `age`: as a decimal value.
-   `sex`, `migration`, `region`: demographic variables (`region` is not
    used in this example).
-   `raw`: PPVT raw score.
-   `group`: age group membership (previously assigned by `cNORM`),
    group labels are mean value of age for all persons in that group.

```{r cNORM-weighting-demo, echo = 1:5, eval = F}
```

`cNORM` requires that the target demographic percentages, or
"marginals", be specified in a multi-level data frame with three
columns:

-   `var`: names of demographic variables in the analysis, each name is
    repeated for the number of categories (levels) in that variable
    (e.g., `sex` has `male` and `female` categories, so it is specified
    twice). `level` and `prop` have values for each category of the
    demographic variables named on `var` (i.e., `level` and `prop` are
    nested within `var`).
-   `level`: numerical coding for categories of `var`.
-   `prop`: target census percentages for categories of `var`, specified
    as decimal proportions.

The columns must be in the left-right sequence shown here. The data
frame is initialized with `data.frame()` and assigned to
`marginals_ppvt`.

![](images/Screen%20Shot%202022-08-18%20at%202.43.24%20PM.png){width="200"}

```{r cNORM-weighting-demo, echo = 7:10, eval = F}
```

The next snippet uses `prop.table(xtabs())` to provide a view (in the
console) of actual percentages of `sex` and `migration` in `norm_data`.
The first two lines process `sex` and `migration` independently. In the
inner parentheses, the variable to be processed is specified with the
formula operator `~`, and the input data object is given in the `data =`
argument. `xtabs()` counts the number of persons in each category of the
named variable, and `prop.table()` converts these counts into decimal
proportions.

The third line processes the cross-tabulation of the two demographic
variables (specified with `~sex + migration`). The values in the
resulting 2 x 2 table are the *joint proportions* for the four
cross-classification cells. For instance, the value in the upper-left
cell is the proportion of persons in the sample who are classified `1`
for `sex`, ***and*** `0` for `migration`.

By contrast, values calculated by the single-variable calls of
`prop.table(xtabs())` are the *marginal proportions* for those
variables, considered independently of one another.

```{r cNORM-weighting-demo, echo = 12:14, eval = F}
```

`computeWeight()` is `cNORM`'s weighting function. Its arguments are the
input data set `data =` and the data frame containing the target census
percentages `population.margins =`.

`computeWeight()` calculates weights for each joint classification cell,
based on the marginal percentages for the demographic variables. It
returns a numerical vector (here assigned to `weights_ppvt`) containing
weights for each person in the normative sample, based on that person's
demographic classification. `computeWeight()` also standardizes the
weights, by dividing each weight by the smallest weight yielded by
analysis. This sets the weight associated with the most over-sampled
joint classification cell to 1. The weights in the current example are:

|            |        Non-migrant        |            Migrant            |
|-----------:|:-------------------------:|:-----------------------------:|
|   **Male** |  Male, Migrant: 1.000000  |  Male, Non-migrant: 1.403915  |
| **Female** | Female, Migrant: 1.007713 | Female, Non-migrant: 1.414743 |

In this script, we pipe `norm_data` into `mutate()` to create a new
column `weights`. Within `mutate()`, we execute `computeWeights()`,
populating the new column with the weights for each person in
`norm_data`.

```{r cNORM-weighting-demo, echo = 16:17, eval = F}
```

The script generates a data frame `norm_data_weights` that shows the
weights associated with the four cross-classification cells. In this
snippet, we group `norm_data` by `sex` and `migration`, which creates a
four-row structure to hold the weights for the cross-classification
cells. We then call `summarize`, which appends a new column `weights` to
the four-row summary table. `unique()` returns only the unique values
from its argument (a vector or column). Here, it fills the `weights`
column with a single correct value for each row.

![](images/Screen%20Shot%202022-08-19%20at%204.10.17%20PM-01.png){width="249"}

```{r cNORM-weighting-demo, echo = 19:23, eval = F}
```

The next code block uses `cnorm()` to execute the normative modeling
process, for both the weighted and original (unweighted) input samples.
Note the use of the argument `weights =` to produce the weighted model.

The code then generates raw-to-norm-score lookup tables for the weighted
and unweighted norm models. The modeling and output table functions of
`cNORM` are documented in detail elsewhere.[^3]

[^3]: See ***Generating raw-to-norm-score lookup tables with
    cNORM*****.**

```{r cNORM-weighting-demo, echo = 24:74, eval = F}
```

Nan Wang of WPS R&D has created a method for comparing raw-to-norm-score
lookup tables based on weighted vs. unweighted data. The method includes
both testing for a statistically significant difference, and calculating
an effect size measure for the difference between weighted and
unweighted tables.

The logic of the statistical test is to view the two lookup tables as
essential two different samples, in which we can use the chi-square test
to compare the distributions of a categorical variable between the two
samples. In this test, the null hypothesis is that there is no
difference between the distributions of the two tables, and the
alternative hypothesis is that a difference exists. The degrees of
freedom for this test is the number of age groups in the raw-to-norm
score lookup tables, minus one (here: 14-1 = 13).

To compare the two tables, we first combine them with `full_join()`, and then drop the `raw` column with `select()`. This returns a single data frame `comp_w_uw` holding only the weighted and unweighted standard score columns, arranged side-by-side.
```{r cNORM-weighting-demo, echo = 75:82, eval = F}
```
The next snippet includes a custom function in base R to conduct the chi-square test on `comp_w_uw`. It appends `comp_w_uw` with a new column `chi-square` that contains row-wise chi-square statistics. To clarify, each row of `comp_w_uw` contains the standard scores corresponding to a single raw score, by age group, for the weighted and unweighted normative models. The chi-square statistic represents a test of whether the null hypothesis can be rejected; that is, that there is a statistically significant difference between the distribution of corresponding standard scores to that raw score, between the weighted and unweighed tables.

We can then obtain the numbers needed to look up the threshold of statistical significance the chi-square distribution table. `chi_sq_max` (here 0.311) is the maximum of the row-wise chi-square statistics, and `df` (here 13) is the degrees of freedom of the statistical test. Examining the chi-square distribution table for df = 13 and p < .05, we find chi-square = 5.89. Comparing `chi_sq_max` to this value, we cannot reject the null hypothesis that there is no difference between the distributions embodied by the two lookup tables. In other words, the weighted and unweighted raw-to-norm-score look up tables, though they may include numerous small pairwise differences between cells, do not differ significantly from each other, when we apply the chi-square test in the manner described.
```{r cNORM-weighting-demo, echo = 83:89, eval = F}
```

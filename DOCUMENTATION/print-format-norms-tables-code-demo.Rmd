---
title: "Converting hand-smoothed norms tables into print-format output"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Overview

The norms development process (i.e., the process of creating raw-to-norm-score[^1] lookup tables) has three stages:

[^1]: In this general overview we refer to "norm scores", rather than specific types of norm scores, such as T scores or IQ-type standard scores. Once the discussion turns to the specific input files used by this script, we will refer to standard scores.

1.  Modeling the raw-to-norm-score relationship using `cNORM` (or custom R code) and create basic lookup tables as output.
2.  Applying manual smoothing to the basic lookup tables, as needed, to prepare the norms for clinical use.
3.  Converting the modified basic lookup tables into print-format lookup tables (or, alternatively, into digital-format lookup tables).

Because Stage 2 is a manual modification of `cNORM` output, Stage 3 cannot be reintegrated into the `cNORM` workflow. Stage 3 must be handled separately, and that is the purpose of this R script. The script takes as input the basic lookup tables and transforms them into the print format. The script assumes a project with age-stratified norms and multiple tests.

It is important to keep in mind that the lookup relationship between raw and norm scores is many-to-one. That is, each raw score value maps onto one and only one norm score value, but each norm score value may map on to more than one raw score value. This many-to-one relationship will be made explicit in following narrative.

At its core, Stage 3 is a transformation in the hierarchical organization of the data. The input tables embody a data hierarchy in which age groups are a subordinate category of tests. Thus, there is one table per test, and each of these tables holds the lookup columns for all age groups. In this documentation, we use the shorthand expressions `test>>age` or `ta` to label the input data hierarchy.

There is also what we might call a "lookup direction" associated with the input tables. That is, one looks up raw scores in a column at the left margin of the table, and reads to the right to find the column with the associated standard scores for a particular age group.

Below is the head of a typical input table, showing the `test>>age` data hierarchy and the left-to-right lookup direction.

    raw    5.0-5.3   5.4-5.7   5.8-5.11   6.0-6.5   6.6-6.11   7.0-7.5   7.6-7.11   8.0-8.5

    0        66        62         58        55         50        47         44        40

    1        70        66         62        58         53        50         47        44

    2        74        70         66        61         57        53         49        46

    3        77        74         70        65         60        56         53        49

    4        80        77         73        68         63        58         55        51

    5        83        80         75        70         65        60         56        53

    6        86        82         77        72         67        62         58        55

    7        89        84         79        74         68        64         60        56

    8        91        86         81        76         70        65         61        57

    9        93        88         83        77         72        67         62        59

Note that the column names are the age range (in `years.months` format) of each age group. Also, reading left--to-right along the rows, each raw score maps onto only one standard score per age group, reflecting the many-to-one relationship between raw and standard scores.

In the print-format lookup tables, the input data hierarchies is inverted: tests are a subordinate category of age groups. That is, there is one table per age group, and each of these tables holds the lookup columns for all tests. We use the shorthand expressions `age>>test` or `at` to label the print-format data hierarchy.

The input lookup direction is reversed in the print-format tables. That is, one looks up raw scores for a particular test in one of the the rightward columns, and reads to the left to find the associated standard score in a column on the left margin.

Below is the head of a typical print-format table, showing the `age>>test` data hierarchy and the right-to-left lookup direction.

    perc    ss    LSK-E   LSW-E  RHY-E  RLN-E  SEG-E  SPW-E 

    98      130    27–33  25–38  21–30  73–120 21–25  20–32

    97      129    -       24      -       72      20      19

    97      128    26      -       20      71      -       -

    96      127    -       23      -       70      -       -

    96      126    -       -       19      68–69  19      18

    95      125    25      22      -       67      -       -

    95      124    -       -       18      66      -       -

    94      123    24      21      17      65      18      17

    93      122    -       -       -       64      -       -

    92      121    23      20      16      63      -       -

Note that the column names are now acronyms, one for each test. Some cells within these columns hold a range of raw scores, rather than a single score. This embodies the many-to-one relationship between raw and standard scores, in which each standard score may map onto more than one raw score.

To track the transformation of the data hierarchy explicitly in the code, we name objects with the `ta` suffix when they express the input (`test>>age` )hierarchy. Similarly, we use the suffix `at` to name objects that embody the print-format (`age>>test`) hierarchy. The suffix `flat` is used to name objects that lack hierarchical structure.

### Executable Code

```{r print-format-norms, eval = FALSE}
suppressMessages(library(here))
suppressMessages(library(tidyverse))
suppressMessages(library(writexl))

input_test_names <- c("lske", "lswe", "rhme", "rlne", "sege", "snwe")
output_test_names <- c("LSK-E", "LSW-E", "RHY-E", "RLN-E", "SEG-E", "SPW-E")
tod_form <- "TOD-E"
norm_type <- "age"
input_file_path <- "INPUT-FILES/PRINT-FORMAT-NORMS-TABLES/"
output_file_path <- "OUTPUT-FILES/PRINT-FORMAT-NORMS-TABLES/"

input_files_ta <- map(
  input_test_names,
  ~
  suppressMessages(read_csv(here(str_c(
  input_file_path, .x, "-", norm_type, ".csv"
))))
) %>% 
  set_names(input_test_names)

perc_ss_cols <- suppressMessages(read_csv(here(str_c(
  input_file_path, "perc-ss-cols.csv"
))))

age_strat <- input_files_ta[[1]] %>% 
  select(-raw) %>% 
  names()

print_lookups_ta <- input_files_ta %>%
  map(~
        .x %>% 
  pivot_longer(contains("-"), names_to = "age_strat", values_to = "ss") %>%
  arrange(age_strat) %>%
  group_by(age_strat) %>%
  complete(ss = 40:130) %>%
  group_by(age_strat, ss) %>%
  filter(n() == 1 | n() > 1 & row_number()  %in% c(1, n())) %>%
  summarize(raw = str_c(raw, collapse = '--')) %>%
  mutate(across(raw, ~ case_when(is.na(.x) ~ '-', TRUE ~ .x))) %>%
  arrange(age_strat, desc(ss)) %>%
  pivot_wider(names_from = age_strat,
              values_from = raw) %>%
  filter(!is.na(ss)) %>%
  right_join(perc_ss_cols, by = "ss") %>%
  relocate(perc, .before = "ss")
) %>% 
  set_names(input_test_names)

age_strat_cols_ta <-  print_lookups_ta %>%
  map( ~
         map(age_strat,
             ~
               .y %>%
               select(perc, ss,!!sym(.x)), .y = .x) %>%
         set_names(age_strat))

age_test_names_flat <- cross2(age_strat, input_test_names) %>% 
  map_chr(str_c, collapse = "_")

age_test_cols_flat <- flatten(age_strat_cols_ta) %>% 
  set_names(age_test_names_flat)

age_test_cols_at <- map(
  age_strat,
  ~
  keep(age_test_cols_flat, str_detect(names(age_test_cols_flat), .x))
)

print_lookups_at <- age_test_cols_at %>% 
  map(
    ~
      .x %>% 
      reduce(left_join, by = c("perc", "ss")) %>% 
      rename_with(~ output_test_names, contains("-"))
  ) %>% 
  set_names(age_strat)

write_xlsx(print_lookups_at,
           here(
             str_c(
               output_file_path, tod_form, "-print-lookup-tables-", norm_type, ".xlsx"
             ))
           )
```

### Commented Snippets

#### I. Load packages, set up tokens, read input files

Load packages for file path specification (`here`), data wrangling (`tidyverse`), and writing files in .xlsx format (`writexl`). Initialize tokens for test names, file paths, and other input parameters. Tokenization of these elements facilitates re-use of the script for different projects with different input parameters. Because these input parameters are used repeatedly throughout the script, specifying them as tokens enables the user to enter the values only once, thus limiting the influence of human data entry error on the script.

```{r print-format-norms, echo = 1:10, eval = F}
```

Use `read_csv()` to read the input files into a list named `input_files_ta`. In this example there are six input files; therefore we `map()` is used to call `read_csv()` iteratively for each input file. The first argument to `map()` is the vector `input_test_names`, one of the tokens initialized at the outset of this script. This vector contains the text strings that distinguish the names of six input files, one for each test. The second argument to `map()` is the function to be applied to iteratively to the input files, namely `read_csv()`. Within `map()`, the function call is set off with the formula notation `~`.

As `map()` iterates over the `input_test_names` vector, it passes one complete file path at a time to `read_csv()`. These file paths are strings, concatenated from tokens and sub-strings with `str_c()`. `map()` returns a list, `input_files_ta`, holding the input files as six data frames. `set_names()` applies the matching test-specific name to each element of the list.

```{r print-format-norms, echo = 12:19, eval = F}
```

The print-format lookup tables include two static columns, one holding all possible standard scores, and the other holding the percentile rank associated with each standard score. Use `read_csv()` to read these columns into a data frame `perc_ss_cols`.

To finalize the print-format tables, a vector containing the names of the age groups is required. These names exist in each of the input files, as column names. To obtain the required vector `age_strat`, we start with a single input file, which is extracted from the list `input_files_ta` with double-bracket `[[]]` subsetting. We call `select(-raw)` to drop the `raw` column, retaining only the age-group columns. We extract the names of these columns into a vector with `names()`.

```{r print-format-norms, echo = 21:27, eval = F}
```

#### II. Impose print-style formatting on the input tables

In the next snippet, we again use `map()` for iterative processing of multiple tables held in a list. Here, `map()` is used to apply a long pipeline of functions to the tables held in the list `input_files_ta`. This list is piped into `map()`, where it is represented by the `.x` token, which sits at the beginning of the pipeline of functions set off by `~`. `map()` thus applies the function chain iteratively to each element of `.x`, returning the list of transformed tables, `print_lookups_ta`. The suffix of this output list denotes that the tables at this stage retain the `test>>age` data hierarchy.

We use `pivot_longer()` to transform each input table to a long, multilevel format, in which a set of standard scores (one for each age group) is nested within each value of raw score. The first argument to `pivot_longer()`, which we specify with `contains("-")`, names the columns to be pivoted to long format (i.e., the columns in the input table that contain the standard scores for each age group). The second argument, `names_to = "age_strat"`, designates a new column whose rows, in long format, will hold the names of the pivoted columns. The third argument, `values_to = "ss"`, designates a new column whose rows, in long format, will hold the cell values (that is, the standard scores) contained in the pivoted columns.

Here we are excluding the `raw` column from the pivot, meaning that in the long table, `raw` remains in the left-most column and becomes a Level 2 variable (in nomenclature of multilevel modeling). The rows of `raw` are expanded such that each raw score value has eight rows, one for each of the eight age groups whose values appear in the `age_strat` column. The new columns, `age_strat` and `ss`, are now Level 1 variables, because they are nested within the Level 2 variable `raw`. We then use `arrange()` to sort the data by `age_strat`.

To visualize the transformation, here are a few rows from the long-format table:

    raw  age_strat  ss

    2    6.6-6.11   57

    2    7.0-7.5    53

    2    7.6-7.11   49

    2    8.0-8.5    46

    3    5.0-5.3    77

    3    5.4-5.7    74

    3    5.8-5.11   70

    3    6.0-6.5    65

As noted above, each value of `raw` now has eight rows, one for each value of `age_strat`. Each value of `age_strat` is paired with its associated value of `ss`, taken from the matching column of the wide-format input table. The sequence of `age_strat` values repeats itself for each new value of `raw`, going down the table.

```{r print-format-norms, echo = 29:33, eval = F}
```

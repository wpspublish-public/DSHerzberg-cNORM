---
title: "cNORM Code Demonstration"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Generating raw-to-norm-score lookup tables with cNORM

#### Overview

This demonstration uses the cNORM package to create publishable norms tables. The demonstration data is from the Tests of Dyslexia (TOD) project (2021). The input file contains data from the TOD-Comprehensive (TOD-C) standardization study, with 1407 cases ranging in age from 6 to 19. The input file includes demographic information and raw scores from three TOD subtests: Irregular Word Spelling (`iws`), Blending (`bln`), and Segmenting (`seg`).

The script proceeds through data preparation, modeling, and output stages. The output includes raw-to-SS lookup tables, in both single-table and tabbed format; a reversal report that flags anomalous age-related changes in standard scores; and a model summary that facilitates replication of the analysis.

To run this demonstration, set up an RStudio project titled `cNORM`, with subfolders `CODE`, `INPUT-FILES` and `OUTPUT-FILES`. Save scripts in `CODE`, and run them from within the `cNORM` project.

#### Executable Code
```{r cNORM-demo, eval = FALSE}
suppressMessages(library(cNORM))
suppressMessages(suppressWarnings(library(tidyverse)))
suppressMessages(library(here))
library(writexl)
suppressMessages(library(lubridate))

urlRemote_path  <- "https://raw.github.com/"
github_path <- "wpspublish/DSHerzberg-cNORM/master/INPUT-FILES/"
data_file_name <- "cNORM-demo-TOD-input-data.csv"

input_original <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, data_file_name)
)))

scores <- c("iws_sum", "bln_sum", "seg_sum")
score_to_norm_stem <- "iws_sum"
score_to_norm_file_name <- str_c(score_to_norm_stem, "-norms-input.csv")
score_to_norm_max_raw <- data.frame(test = score_to_norm_stem) %>%
  mutate(max_raw = case_when(
    str_detect(test, "iws_sum") ~ 44,
    str_detect(test, "bln_sum") ~ 29,
    str_detect(test, "seg_sum") ~ 29
  )) %>%
  pull(max_raw)

age_contin <- input_original %>%
  mutate(across(c(DOB, admin_date),
                ~
                  mdy(.x)),
         age = (DOB %--% admin_date) / years (1)) %>%
  bind_cols(getGroups(.$age)) %>%
  rename(group = ...14) %>%
  select(ID, age, group)

map(
  scores,
  ~
    input_original %>%
    select(ID,!!sym(.x)) %>%
    drop_na(!!sym(.x)) %>%
    left_join(age_contin, by = "ID") %>%
    rename(raw = !!sym(.x)) %>%
    select(ID, age, group, raw)
) %>%
  set_names(scores) %>%
  map2(scores,
       ~
         write_csv(.x,
                   here(
                     str_c("OUTPUT-FILES/", .y, "-norms-input.csv")
                   ))) %>%
  invisible(.)

input <- suppressMessages(read_csv(here(
  str_c("OUTPUT-FILES/", score_to_norm_file_name)
)))

model <- cnorm(
  raw = input$raw,
  group = input$group,
  k = 4,
  terms = 4,
  scale = "IQ"
)

plot(model, "series", end = 8)
checkConsistency(model)

tab_names <- c(
  "6.0-6.3",
  "6.4-6.7",
  "6.8-6.11",
  "7.0-7.3",
  "7.4-7.7",
  "7.8-7.11",
  "8.0-8.5",
  "8.6-8.11",
  "9.0-9.5",
  "9.6-9.11",
  "10.0-10.5",
  "10.6-10.11",
  "11.0-11.5",
  "11.6-11.11",
  "12.0-12.5",
  "12.6-12.11",
  "13.0-13.11",
  "14.0-14.11",
  "15.0-16.11",
  "17.0-18.11"
)

norms_list <- rawTable(
  c(
    6.167,
    6.5,
    6.833,
    7.167,
    7.5,
    7.833,
    8.25,
    8.75,
    9.25,
    9.75,
    10.25,
    10.75,
    11.25,
    11.75,
    12.25,
    12.75,
    13.5,
    14.5,
    16,
    18.0
  ),
  model,
  step = 1,
  minNorm = 40,
  maxNorm = 130,
  minRaw = 1,
  maxRaw = score_to_norm_max_raw,
  pretty = FALSE
) %>%
  set_names(tab_names) %>%
  map(~
        select(.x, raw, norm) %>%
        summarize(raw = raw,
                  ss = round(norm, 0)))

reversal_report <- norms_list %>%
  reduce(left_join,
         by = "raw") %>%
  set_names("raw", tab_names) %>%
  pivot_longer(-raw, names_to = "agestrat", values_to = "ss") %>%
  group_by(raw) %>%
  mutate(reversal = case_when(lag(ss) < ss ~ 1)) %>%
  filter(reversal == 1) %>%
  select(raw, agestrat) %>%
  write_csv(here(
    str_c("OUTPUT-FILES/", score_to_norm_stem, "-reversal-report-age.csv")
  ))

write_xlsx(norms_list,
           here(
             str_c(
               "OUTPUT-FILES/", 
               score_to_norm_stem,
               "-raw-ss-lookup-tabbed-age.xlsx"
             )
           ))

table <- norms_list %>%
  reduce(left_join,
         by = "raw") %>%
  set_names("raw", tab_names)

write_csv(table, 
          here(
  str_c("OUTPUT-FILES/", score_to_norm_stem, "-raw-ss-lookup-table-age.csv")
))

capture.output(
  str_c(score_to_norm_stem, " model summary"), 
  summary(model),
  file = here(
    str_c("OUTPUT-FILES/", score_to_norm_stem, "-model-summ-age.txt")  )
)
```

#### Commented Snippets

##### 1. Data Preparation
Load packages for norming (`cNORM`), data wrangling (`tidyverse`), file path specification (`here`), writing .xlsx output (`writexl`), and working with data/time data (`lubridate`). Specifiy file path tokens. `read_csv()` the input data set into `input_original`, using the `url()` function to retrieve data from a remote website. Use `str_c()` to concatenate file path tokens into single path.
```{r cNORM-demo, echo = 1:14, eval = F}
```
Specify score related tokens. `score_to_norm_max_raw` is a numerical vector containing the maximum possible raw score for the score being normed on the current iteration of the script.

To generate this vector, start by using `data.frame(test = score_to_norm_stem)` to initialize a single-cell data frame, with the `test` column holding the name of the score to be normed. Use `mutate()` to create a second column (`max_raw`) containg the maximum value for that score.

Use `case_when()` to code `max_raw` conditionally, based on the value of `test`. For example, `str_detect(test, "iws_sum")` returns `TRUE` when the value of `test` contains the string `"iws_sum"`. Under that condition, `case_when()` sets the value of `max_raw` to `44`. 

`mutate()` returns a two-column data frame. Use `pull()` to extract the value of `max_raw` into the vector `score_to_norm_max_raw`.

```{r cNORM-demo, echo = 16:24, eval = F}
```
A useful feature of `cNORM` is its capacity to create its own age-stratrification, constructing age groups that are best suited to the modeling of age-related score changes. Often, _a priori_ age groups, which serve the needs of the audience for published norms, do not stratify the input sample in a way that is optimal for the `cNORM` modeling functions. However, cNORM also allows the respecification of these _a priori_ groups on the output side. As we shall see, whatever age-stratification scheme best suits the needs of the audience for published norms, can be instituted in the final output of `cNORM`.

To use this feature, create a new data frame `age_contin` holding a continuous decimal age variable for each case in the input file. Use `mutate(across())` and `lubridate::mdy()` to coerce the date variables (`DOB`, `admin_date`), which are strings in the input file, into a numeric date-time format. Within `mdy()`, the `.x` token represents the variables designated for transformation by `across()`.

Within the same call of `mutate()`, calculate a new decimal `age` variable. The `%--%` operator of `lubridate` creates an arithmetic date-time interval, or duration, between a start date (here `DOB`) and an end date (here `admin_date`). Dividing this interval, which represents chronological age, by a time period (here `years(1)`, which returns 1 year as an arithmetic date-time period), returns a decimal value for chronological age expressed as years-months-days (e.g., 5 years, 6 months, 0 days = 5.5).

Use `cNORM::getGroups(.$age)` to obtain age-stratification optimized for the norms modeling process. `.$age` indicates that `getGroups()` is to operate on the `age` column of the current data object. 

By default, `getGroups()` attempts to form equal-sized age groups with about 100 cases each. Below are the labels for the 15 age groups that `getGroups()` created from the input sample, which has 1407 cases. Each label is the arithmetic mean of the `age` variable for the cases assigned to that group.
```
6.964081  
8.016325  
8.612022  
9.113898  
9.694660 
10.378862 
11.024620
11.689430 
12.409892 
13.102322 
13.851553 
14.827028 
15.693530 
16.688863
17.971970
```
Wrapping `getGroups()` in `bind_cols()` adds a new column to the input data object. This new column, which is provisionally named `...14` for its position in the current data object, contains the age-group assignment for each case in the input sample. Complete the setup of the `age_contin` data frame by renaming `...14` to the more meaningful `group`, and subsetting the columns with `select()`.

```{r cNORM-demo, echo = 26:34, eval = F}
```
The `cNORM` norming process operates on one score at a time. For tests with multiple subtest scores that need to be normed, the workflow is to feed one score at a time through the `cNORM` script. The next code block partitions the example data file, which contains three subtest scores for each case, into separate data frames for each score containing only the variables needed by `cNORM`.

The code includes two iterative segments. In the first, `map()` is used to apply a series of functions to each element of the `scores` vector, which contains the names of the three subtest scores in the input data set. Within `map`, `.x` represents the currently-iterated element of the `scores` vector (i.e., one subtest score).

In the function pipeline, `input_original` is sent to `select` to subset the columns to only those required by `cNORM`, which are the case `ID` and the subtest score to be normed. Because the vector `scores` contains quoted strings, and `select()` expects unquoted column names, `!!sym(.x)` is used to unquote the currently iterated subtest name. This same operation is employed within other functions in this pipeline.

`drop_na()` drops rows (cases) that are missing the subtest score currently being normed. `left_join()` joins the current object with the previously created `age_contin`, matching cases `by = "ID"`. To obtain the columns require by `cNORM`, `rename()` changes the subtest score name to the generic `raw`, and `select()` subsets the columns.

At this point, `map()` has finished its operation, returning a list of unnamed dataframes, one for each subtest score, containing the variables required by `cNORM`. `set_names(scores)` is used to name each data frame with its corresponding subtest label.

Next, the list of data frames is piped into `map2()`, which enables simultaneous parallel iteration over two inputs of equal length (tokenized as `.x` and `.y`). In this call of `map2()`, the current piped object (the list of data frames) is the `.x` input, and the `scores` vector is the `.y` input.

The purpose of the `map2()` call is to write each of the data frames on the input list to an external `.csv` file, where it can be read in for processing by `cNORM`.
```{r cNORM-demo, echo = 35:53, eval = F}
```

